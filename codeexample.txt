Estrutura FINAL correta (igual ao teu projeto)
Include/
 â”œâ”€â”€ features/
 â”‚    â””â”€â”€ Smoke/
 â”‚         â””â”€â”€ UserAccess/
 â”‚              â””â”€â”€ Login.feature
 â”‚
 â””â”€â”€ scripts/
      â””â”€â”€ groovy/
           â””â”€â”€ stepDefinitions/
                â””â”€â”€ UserAccess/
                     â””â”€â”€ LoginSteps.groovy


Keywords/
 â”œâ”€â”€ BasePage.groovy
 â””â”€â”€ Page_Login.groovy


Object Repository/
 â””â”€â”€ Pages/
     â””â”€â”€ UserAccess/
         â””â”€â”€ Login/
             â”œâ”€â”€ input_username
             â”œâ”€â”€ input_password
             â”œâ”€â”€ btn_signIn
             â”œâ”€â”€ dashboard_home
             â””â”€â”€ login_error_message


Data Files/
 â””â”€â”€ LoginUsers   (Excel importado)

Agora sim â€” isto bate certo com o que estÃ¡s a ver.

âœ… 1) Login.feature

ğŸ“Œ Include/features/Smoke/UserAccess/Login.feature

Feature: User Login


  As a user of the system
  I want to login with valid or invalid credentials
  So that authentication is validated correctly


  @smoke @login
  Scenario Outline: Login validation with different credentials


    Given the user opens the browser
    And the user navigates to the login page


    When the user logs in as "<role>" using "<sheet>"


    Then the login result should be "<expectedResult>"


    Examples:
      | role        | sheet               | expectedResult |
      | Admin       | ValidCredentials    | success        |
      | Admin       | InvalidCredentials  | error          |
      | Approver 1  | ValidCredentials    | success        |
      | Approver 1  | InvalidCredentials  | error          |
âœ… 2) LoginSteps.groovy

ğŸ“Œ LOCAL CORRETO:

Include/scripts/groovy/stepDefinitions/UserAccess/LoginSteps.groovy
package stepDefinitions.UserAccess


import com.kms.katalon.core.webui.keyword.WebUiBuiltInKeywords as WebUI


import cucumber.api.java.en.Given
import cucumber.api.java.en.When
import cucumber.api.java.en.Then


// Page Object em Keywords (default package)
import Page_Login


class LoginSteps {


    Page_Login loginPage = new Page_Login()


    @Given("the user opens the browser")
    def openBrowser() {
        WebUI.openBrowser("")
        WebUI.maximizeWindow()
    }


    @Given("the user navigates to the login page")
    def navigateToLoginPage() {
        loginPage.goToLoginPage()
    }


    @When("the user logs in as {string} using {string}")
    def loginUsingExcel(String role, String sheet) {
        loginPage.loginWithRole(role, sheet)
    }


    @Then("the login result should be {string}")
    def verifyLoginResult(String expectedResult) {


        if (expectedResult.equalsIgnoreCase("success")) {
            loginPage.verifyLoginSuccess()
        }
        else if (expectedResult.equalsIgnoreCase("error")) {
            loginPage.verifyLoginError()
        }
        else {
            throw new Exception("Unknown expectedResult: " + expectedResult)
        }


        WebUI.closeBrowser()
    }
}
âœ… 3) BasePage.groovy

ğŸ“Œ Keywords/BasePage.groovy

âš ï¸ Sem packages, porque estÃ¡ no default package.

import com.kms.katalon.core.webui.keyword.WebUiBuiltInKeywords as WebUI
import com.kms.katalon.core.model.FailureHandling


class BasePage {


    def waitForElement(def obj, int timeout = 10) {
        WebUI.waitForElementVisible(obj, timeout, FailureHandling.STOP_ON_FAILURE)
    }


    def click(def obj) {
        waitForElement(obj)
        WebUI.click(obj)
    }


    def type(def obj, String text) {
        waitForElement(obj)
        WebUI.setText(obj, text)
    }


    def verifyPresent(def obj) {
        WebUI.verifyElementPresent(obj, 10, FailureHandling.STOP_ON_FAILURE)
    }
}
âœ… 4) Page_Login.groovy

ğŸ“Œ Keywords/Page_Login.groovy

import static com.kms.katalon.core.testobject.ObjectRepository.findTestObject
import static com.kms.katalon.core.testdata.TestDataFactory.findTestData


import com.kms.katalon.core.testdata.TestData
import com.kms.katalon.core.webui.keyword.WebUiBuiltInKeywords as WebUI


import internal.GlobalVariable


class Page_Login extends BasePage {


    // Login objects
    def usernameField = findTestObject("Pages/UserAccess/Login/input_username")
    def passwordField = findTestObject("Pages/UserAccess/Login/input_password")
    def signInButton  = findTestObject("Pages/UserAccess/Login/btn_signIn")


    // Validation objects
    def dashboardHome = findTestObject("Pages/UserAccess/Login/dashboard_home")
    def loginErrorMsg = findTestObject("Pages/UserAccess/Login/login_error_message")


    // Navigate
    def goToLoginPage() {
        WebUI.navigateToUrl(GlobalVariable.baseUrl + "/login")
    }


    // Login using Excel role + sheet
    def loginWithRole(String role, String sheetName) {


        TestData data = findTestData("LoginUsers")
        data.changeSheet(sheetName)


        for (int i = 1; i <= data.getRowNumbers(); i++) {


            String excelRole = data.getValue("role", i)


            if (excelRole != null && excelRole.equalsIgnoreCase(role)) {


                String username = data.getValue("user", i)
                String password = data.getValue("password", i)


                type(usernameField, username)
                type(passwordField, password)
                click(signInButton)


                return
            }
        }


        throw new Exception("Role not found in Excel: " + role + " (Sheet: " + sheetName + ")")
    }


    // Success validation
    def verifyLoginSuccess() {
        verifyPresent(dashboardHome)
    }


    // Error validation
    def verifyLoginError() {
        verifyPresent(loginErrorMsg)
    }
}
âœ… 5) Object Repository obrigatÃ³rio

Cria estes 5 objects:

Object Name	XPath exemplo
input_username	//input[@name='username']
input_password	//input[@name='password']
btn_signIn	//button[@type='submit']
dashboard_home	//h1[@class='maintitle']
login_error_message	//div[contains(@class,'error')]
âœ… 6) Excel Data File

Importa o Excel como:

ğŸ“Œ Data Files/LoginUsers

Sheets:

ValidCredentials

InvalidCredentials

Colunas:

user

password

role






------------------
âœ… Plano perfeito agora (passo a passo)
1) Instala o Katalon limpo

Quando abrir, confirma em:

Help â†’ About

Que estÃ¡s tipo:

Katalon 10.x

Java 17 embedded

2) Cria um projeto novo vazio primeiro

ğŸ“Œ SÃ³ para testar que estÃ¡ tudo OK.

File â†’ New â†’ Project â†’ Web

Nome:

TestClean
3) Testa se o Cucumber funciona sem erro

Cria:

Include/features/login.feature
Feature: Smoke


  Scenario: Open browser
    Given open browser

Agora:

Step Definition

Right click â†’ New â†’ Step Definition

Package:

steps

Class:

SmokeSteps

CÃ³digo:

package steps


import com.kms.katalon.core.webui.keyword.WebUiBuiltInKeywords as WebUI
import cucumber.api.java.en.Given


class SmokeSteps {


  @Given("open browser")
  def openBrowser() {
    WebUI.openBrowser("")
    WebUI.closeBrowser()
  }
}

â–¶ Run

Se isto correr â†’ acabou, tens Katalon saudÃ¡vel.


import com.kms.katalon.core.annotation.BeforeTestSuite
import com.kms.katalon.core.cucumber.keyword.CucumberBuiltinKeywords
import com.kms.katalon.core.cucumber.keyword.internal.CucumberGlueGenerator

class CucumberSetup {

    @BeforeTestSuite
    def setupCucumberGlue() {
        CucumberBuiltinKeywords.GLUE = [
            'Include.steps'
        ]
        CucumberGlueGenerator.addDefaultPackages()
    }





A aplicaÃ§Ã£o Ã© do domÃ­nio de procurement, com workflows complexos (serviÃ§os vs materiais), mÃºltiplos roles e regras de aprovaÃ§Ã£o que multiplicam os cenÃ¡rios.
Neste momento sou a Ãºnica pessoa no projeto, nÃ£o existe ainda uma framework estÃ¡vel (POM/waits/reporting) e nÃ£o hÃ¡ API disponÃ­vel, portanto grande parte da automaÃ§Ã£o terÃ¡ de ser feita via UI.
SÃ³ em navegaÃ§Ã£o existem cerca de 195 menus/submenus, que devem ser cobertos via abordagem data-driven para garantir estabilidade.
Estimativa realista por fases:
FundaÃ§Ã£o + primeiros smoke tests estÃ¡veis: 3â€“8 semanas
Cobertura automatizada de navegaÃ§Ã£o/menus: +2â€“4 semanas
Fluxos crÃ­ticos procurement (criaÃ§Ã£o â†’ aprovaÃ§Ã£o â†’ PO â†’ receÃ§Ã£o): 1â€“5 dias por fluxo, ou seja:
Top 10 fluxos: 2â€“8 semanas
Top 30 fluxos: 2â€“6 meses
As decision tables de aprovaÃ§Ã£o nÃ£o sÃ£o realistas de cobrir 100% via UI, devido Ã  combinatÃ³ria. O recomendado Ã© priorizaÃ§Ã£o por risco e amostragem (boundary/equivalence), ou entÃ£o suporte tÃ©cnico adicional (hooks/endpoints internos).
Proponho um roadmap faseado orientado a risco, garantindo entregas rÃ¡pidas e crescimento contÃ­nuo da cobertura.






Claro ğŸ˜„ vamos fazer isto bem feito e pronto para apresentares ao cliente/coordenaÃ§Ã£o.
Vou-te dar um plano por fases, com entregas claras, tempos realistas para 1 pessoa, e linguagem â€œenterpriseâ€.
âœ… Plano por Fases â€” AutomaÃ§Ã£o Procurement (Katalon + POM + Cucumber)
Contexto (assumptions)
1 QA engineer dedicado
Projeto atual sem framework estÃ¡vel
Sem API layer â†’ automaÃ§Ã£o maioritariamente via UI
AplicaÃ§Ã£o procurement com workflows complexos (7 fluxos principais)
~195 menus/submenus
CI serÃ¡ integrado mais tarde no Jenkins do cliente
ğŸ¯ Objetivo geral
Entregar automaÃ§Ã£o sustentÃ¡vel e escalÃ¡vel, com valor rÃ¡pido (smoke), e expansÃ£o incremental por risco.
âœ… FASE 0 â€” FundaÃ§Ã£o (Framework & Standards)
Objetivo
Construir a base profissional para evitar testes frÃ¡geis e dÃ­vida tÃ©cnica.
EntregÃ¡veis
Arquitetura Page Object Model
Estrutura BDD com Cucumber
Keywords reutilizÃ¡veis (navigation, login, approvals)
EstratÃ©gia de waits/sincronizaÃ§Ã£o
Reporting + evidÃªncias (screenshots/logs)
Data-driven preparado (Excel/CSV)
Execution profiles (dev/test/preprod)
Tempo realista
ğŸ“Œ 3 a 8 semanas
Sem esta fase, qualquer tentativa de â€œautomatizar tudoâ€ vira scripts instÃ¡veis e impossÃ­vel de manter.
âœ… FASE 1 â€” Smoke Suite + NavegaÃ§Ã£o (195 menus/submenus)
Objetivo
Garantir que a aplicaÃ§Ã£o â€œnÃ£o estÃ¡ partidaâ€ e que toda a navegaÃ§Ã£o principal carrega.
EstratÃ©gia recomendada
1 teste data-driven que percorre os menus/submenus
ValidaÃ§Ã£o por â€œsentinel elementâ€ (pÃ¡gina carregou)
EntregÃ¡veis
Cobertura estrutural completa de navegaÃ§Ã£o
Primeira suite smoke executÃ¡vel
Tempo realista
ğŸ“Œ 2 a 4 semanas
âœ… FASE 2 â€” Fluxos Procurement CrÃ­ticos (Happy Paths)
Objetivo
Automatizar os fluxos que trazem valor imediato ao negÃ³cio.
Exemplos tÃ­picos
Criar Purchase Request (material)
Criar Purchase Request (serviÃ§o)
AprovaÃ§Ã£o Manager
AprovaÃ§Ã£o Finance
ConversÃ£o em Purchase Order
ReceÃ§Ã£o / ConfirmaÃ§Ã£o
Ritmo realista (UI-only)
1â€“2 fluxos completos por sprint (2 semanas)
Tempo para top 10 fluxos
ğŸ“Œ 2 a 8 semanas
âœ… FASE 3 â€” Workflows Complexos (7 fluxos principais)
Objetivo
Cobrir os workflows completos com variaÃ§Ãµes principais.
Realidade procurement
Cada fluxo (como o diagrama que mostraste) = 20â€“50 cenÃ¡rios
Tempo realista por fluxo complexo
ğŸ“Œ 2 a 4 semanas por workflow
Para 7 fluxos principais
ğŸ“Œ 4 a 8 meses (entregue incrementalmente)
âœ… FASE 4 â€” Decision Tables & Edge Cases
Objetivo
Cobrir regras complexas sem tentar â€œtodas as combinaÃ§Ãµesâ€.
Abordagem correta
Boundary values
Equivalence classes
Risk-based sampling
Nota importante
Cobertura 100% combinatÃ³ria via UI Ã© impraticÃ¡vel sem API/test hooks.
Tempo
ğŸ“Œ ContÃ­nuo / backlog evolutivo
âœ… FASE 5 â€” IndustrializaÃ§Ã£o no Jenkins do Cliente
Objetivo
Transformar automaÃ§Ã£o em pipeline enterprise.
EntregÃ¡veis
ExecuÃ§Ã£o headless
GestÃ£o de credenciais/secrets
Reports exportÃ¡veis
Scheduling + regression packs
Tempo tÃ­pico
ğŸ“Œ 1 a 3 semanas (dependente do cliente)
ğŸ“ Timeline Executiva (para management)
Fase
Entrega
Tempo
0
Framework (POM + BDD + base estÃ¡vel)
1â€“2 meses
1
Smoke + 195 menus automatizados
+2â€“4 semanas
2
Top fluxos crÃ­ticos procurement
+1â€“2 meses
3
7 workflows completos
+4â€“8 meses
4
Decision tables (amostragem)
contÃ­nuo
5
Jenkins cliente
+1â€“3 semanas
âœ… Mensagem final para o cliente (1 frase poderosa)
â€œAutomation in procurement is delivered as a phased roadmap: a stable foundation in 6â€“8 weeks, then incremental workflow coverage sprint by sprint. Full coverage is a multi-month program, not a single milestone.â€
ğŸš€ PrÃ³ximo passo (para ficar perfeito)
Se me deres os nomes dos 7 fluxos principais, eu monto-te uma tabela estilo consultoria:
Fluxo
NÂº decisÃµes
NÂº cenÃ¡rios estimados
Prioridade
Tempo por fase
Isso vira um documento que o cliente aceita imediatamente.
Quais sÃ£o os 7 fluxos?
